import numpy as np
import matplotlib.pyplot as plt
import sys

class CahnHilliardPhysics():
    """
    Class for computing physics of 1D Cahn Hilliard equations.

    **Inputs**

    ----------
    inputs : InputFile
        InputFile specifying various things needed for constructor.
    state : CahnHilliardState
        Initial state needed for constructor.
    """
    def __init__(self,inputs,state):
        self.inputs     = inputs
        self.state      = state
        self.grid       = state.grid
        self.t_step     = 0
        self.t_steps    = inputs.t_steps
        self.dt         = inputs.dt
        
    def get_current_state(self):
        """
        Method to return current state.
        """
        return self.state.C[self.t_step]

    def update_state(self,Cnew):
        """
        Method to push new state to stack.
        """
        self.state.push_state_to_stack(Cnew)
        self.t_step = self.state.C.shape[0] - 1

    def set_current_state(self,C):
        """
        Method to set current state.
        """
        self.state.C[self.t_step] = C

    def compute_laplacian(self,field):
        """
        Method to compute Laplacian of 1-D field with finite differencing on a uniform, structured grid.
        Note that this is only computed on the interior (boundary points are set to zero)
        """
        dx         = self.grid[1]-self.grid[0]
        N          = len(self.grid)
        lapl       = np.zeros(N)
        lapl[1:-1] = ( field[0:-2] - 2*field[1:-1] + field[2:] ) / (dx**2)
        return lapl

    def compute_D4(self,f):
        """
        Method to compute D4 of 1-D field with finite differencing on a uniform, structured grid.
        Note that this is only computed on the interior (boundary points are set to zero)
        """
        dx           = self.grid[1]-self.grid[0]
        N            = len(self.grid)
        biharm       = np.zeros(N)
        biharm[2:-2] = (f[0:-4] - 4*f[1:-3] + 6*f[2:-2] - 4*f[3:-1] + f[4:]) / (dx**4)
        biharm[1]    = (3*f[1] - 14*f[2] + 26*f[3] - 24*f[4] + 11*f[5] - 2*f[6]) / (dx**4)
        biharm[-2]   = (-2*f[-7] + 11*f[-6] - 24*f[-5] + 26*f[-4] - 14*f[-3] + 3*f[-2]) / (dx**4)
        return biharm

    def compute_laplacian_at_point_with_three_point_stencil(self,L,C,R):
        dx = self.grid[1]-self.grid[0]
        return (L - 2*C + R) / (dx**2)
        
    def compute_RHS(self):
        """
        Method to compute the RHS of the CH physics.
        """
        # Governing parameters
        D1 = self.inputs.D1
        D2 = self.inputs.D2
        # Current state
        C  = self.get_current_state()
        # RHS: D1*lapl(c^3 - c -D2*lapl(c))
        d4_C       = self.compute_D4(C)
        d2_terms   = self.compute_laplacian(C**3 - C)
        RHS        = D1*(d2_terms - D2*d4_C)
        return RHS

    def compute_RHS_at_point_with_five_point_stencil(self,LL,L,C,R,RR):
        """
        Method to compute RHS at a center point with a 5-point stencil
        """
        # Governing parameters
        D1 = self.inputs.D1
        D2 = self.inputs.D2
        # RHS: D1*lapl(c^3 - c -D2*lapl(c))
        lapl_L     = self.compute_laplacian_at_point_with_three_point_stencil(LL,L,C)
        lapl_C     = self.compute_laplacian_at_point_with_three_point_stencil(L,C,R)
        lapl_R     = self.compute_laplacian_at_point_with_three_point_stencil(C,R,RR)
        chem_pot_L = L**3 - L - D2*lapl_L
        chem_pot_C = C**3 - C - D2*lapl_C
        chem_pot_R = R**3 - R - D2*lapl_R
        RHS        = D1*self.compute_laplacian_at_point_with_three_point_stencil(chem_pot_L,chem_pot_C,chem_pot_R)
        return RHS
    

    def apply_BCs(self,C):
        """
        Method to apply BCs to the state.
        """
        C = C.ravel()
        if (self.inputs.BC == 'zero_flux'):
            C[0]  = C[1]
            C[-1] = C[-2]
        elif (self.inputs.BC == 'zero_value'):
            C[0]  = 0
            C[-1] = 0
        elif (self.inputs.BC == 'periodic'):
            C[-1] = C[1]
            C[0]  = C[-2]
        else:
            sys.exit('Boundary condition type either not specified or not supported')
        C = C.reshape((1,-1))
        return C
